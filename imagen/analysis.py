"""
The ImaGen analysis module provides common analysis functions, which
can be applied to any SheetView or SheetStack. This allows the user to
perform analyses on their input patterns or any other arrays embedded
within a SheetView and display the output of the analysis alongside
the original patterns.

Currently this module provides FFT, auto-correlation and gradient
analyses.
"""

import numpy as np
from numpy.fft.fftpack import fft2
from numpy.fft.helper import fftshift

from matplotlib import pyplot as plt

import param
from param import ParamOverrides

from dataviews import Overlay
from dataviews import SheetView, SheetStack, SheetLayer, SheetLines, SheetOverlay
from dataviews import DataLayer, DataStack, Stack
from dataviews import TableView, TableStack
from dataviews import GridLayout, CoordinateGrid, DataGrid
from dataviews.sheetcoords import BoundingBox

from dataviews.styles import Styles, Style, Cycle

from imagen import wrap


stack_mapping = {SheetLayer:SheetStack,
                 DataLayer:DataStack,
                 TableView:TableStack}


class ViewOperation(param.ParameterizedFunction):
    """
    A ViewOperation takes one or more views as inputs and processes
    them, returning arbitrary new view objects as output. Individual
    dataviews may be passed in directly while multiple dataviews must
    be passed in as a Stack of the appropriate type. A ViewOperation
    may be used to implement simple dataview manipulations or perform
    complex analysis.

    Internally, ViewOperations operate on the level of individual
    dataviews, processing each layer on an input Stack independently.
    """

    def _process(self, view):
        """
        Process a single input view and output a list of views. When
        multiple views are returned as a list, they will be returned
        to the user as a GridLayout. If a Stack is passed into a
        ViewOperation, the individual layers are processed
        sequentially.
        """
        raise NotImplementedError

    def get_views(self, view, pattern, view_type=SheetView):
        """
        Helper method that return a list of views with labels ending
        with the given pattern and which have the specified type. This
        may be useful to check is a single view satisfies some
        condition or to extract the appropriate views from an Overlay.
        """
        if isinstance(view, Overlay):
            matches = [v for v in view.data if v.label.endswith(pattern)]
        elif isinstance(view, SheetView):
            matches = [view] if view.label.endswith(pattern) else []

        return [match for match in matches if isinstance(match, view_type)]


    def _get_signature(self, view_lists):
        """
        Given a sequence of view lists generated by the _process
        method, find the fundamental view types required to select the
        appropriate Stack type. All lists are examined to ensure that
        the fundamental types are consistent across all items.
        """
        signature = None
        for views in view_lists:
            view_signature = []
            for v in views:
                if type(v) in [CoordinateGrid, DataGrid]:
                    raise NotImplementedError("CoordinateGrid and DataGrid not supported yet")
                matches = [k for k in stack_mapping if issubclass(type(v),k)]
                assert len(matches) == 1
                view_signature.append(matches[0])

            if signature is None:
                signature = view_signature

            if signature != view_signature:
                raise Exception('The ViewOperation is returning inconsistent types.')

        return signature


    def __call__(self, view, **params):
        self.p = ParamOverrides(self, params)

        if not isinstance(view, Stack):
            views = self._process(view)
            if len(views) > 1:
                return GridLayout([views])
            else:
                return views[0]
        else:
            mapped_items = [(k, self._process(el)) for k, el in view.items()]
            signature = self._get_signature(el[1] for el in mapped_items)

            stack_types = [stack_mapping[tp] for tp in signature]
            stacks = [stack_tp(dimensions=view.dimensions,
                               metadata=view.metadata) for stack_tp in stack_types]

            for k, views in mapped_items:
                for ind, v in enumerate(views):
                    stacks[ind][k] = v

            if len(stacks) == 1:
                return stacks[0]
            else:
                return GridLayout([stacks])



class fft_power_spectrum(ViewOperation):
    """
    Compute the 2D Fast Fourier Transform (FFT) of the supplied sheet view.

    Example::
    fft_power_spectrum(topo.sim.V1.views.maps.OrientationPreference)
    """

    peak_val = param.Number(default=1.0)

    def _process(self, sheetview):
        cr = sheetview.cyclic_range
        data = sheetview.data if cr is None else sheetview.data/cr
        fft_spectrum = abs(fftshift(fft2(data - 0.5, s=None, axes=(-2, -1))))
        fft_spectrum = 1 - fft_spectrum # Inverted spectrum by convention
        zero_min_spectrum = fft_spectrum - fft_spectrum.min()
        spectrum_range = fft_spectrum.max() - fft_spectrum.min()
        normalized_spectrum = (self.p.peak_val * zero_min_spectrum) / spectrum_range

        l, b, r, t = sheetview.bounds.lbrt()
        density = sheetview.xdensity
        bb = BoundingBox(radius=(density/2)/(r-l))

        return [SheetView(normalized_spectrum, bb,
                          metadata=sheetview.metadata,
                          label=sheetview.label+' FFT Power Spectrum')]



class gradient(ViewOperation):
    """
    Compute the gradient plot of the supplied SheetView or SheetStack.
    Translated from Octave code originally written by Yoonsuck Choe.

    If the SheetView has a cyclic_range, negative differences will be
    wrapped into the range.

    Example:: gradient(topo.sim.V1.views.maps.OrientationPreference)
    """

    def _process(self, sheetview):
        data = sheetview.data
        r, c = data.shape
        dx = np.diff(data, 1, axis=1)[0:r-1, 0:c-1]
        dy = np.diff(data, 1, axis=0)[0:r-1, 0:c-1]

        cyclic_range = 1.0 if sheetview.cyclic_range is None else sheetview.cyclic_range
        if cyclic_range is not None: # Wrap into the specified range
            # Convert negative differences to an equivalent positive value
            dx = wrap(0, cyclic_range, dx)
            dy = wrap(0, cyclic_range, dy)
            #
            # Make it increase as gradient reaches the halfway point,
            # and decrease from there
            dx = 0.5 * cyclic_range - np.abs(dx - 0.5 * cyclic_range)
            dy = 0.5 * cyclic_range - np.abs(dy - 0.5 * cyclic_range)

        return [SheetView(np.sqrt(dx*dx + dy*dy), sheetview.bounds,
                          metadata=sheetview.metadata,
                          label=sheetview.label+' Gradient')]



class autocorrelation(ViewOperation):
    """
    Compute the 2D autocorrelation of the supplied data. Requires the
    external SciPy package.

    Example::
    autocorrelation(topo.sim.V1.views.maps.OrientationPreference)
    """

    def _process(self, sheetview):
        import scipy.signal
        data = sheetview.data
        autocorr_data = scipy.signal.correlate2d(data, data)
        return [SheetView(autocorr_data, sheetview.bounds,
                         metadata=sheetview.metadata,
                          label=sheetview.label+' AutoCorrelation')]



class contours(ViewOperation):
    """
    Given a SheetView with a single channel, annotate it with contour
    lines for a given set of contour levels.

    The return is a overlay with a SheetLines layer for each given
    level, overlaid on top of the input SheetView.
    """

    levels = param.NumericTuple(default=(0.5,), doc="""
         A list of scalar values used to specify the contour levels.""")

    def _process(self, sheetview):

        figure_handle = plt.figure()
        (l,b,r,t) = sheetview.bounds.lbrt()
        contour_set = plt.contour(sheetview.data,
                                  extent=(l,r,t,b),
                                  levels=self.p.levels)

        sheetlines = []
        for level, cset in zip(self.p.levels, contour_set.collections):
            paths = cset.get_paths()
            lines = [path.vertices for path in paths]
            sheetline = SheetLines(lines,
                                   sheetview.bounds,
                                   metadata={'level':level},
                                   label=sheetview.label+' Contours')
            sheetlines.append(sheetline)

        plt.close(figure_handle)

        if len(sheetlines) == 1:
            return [(sheetview * sheetlines[0])]
        else:
            return [sheetview * SheetOverlay(sheetlines,
                                             sheetview.bounds)]


class cyclic_similarity_index(ViewOperation):
    """
    The similarity index between any two cyclic maps. By default, a
    zero value indicates uncorrelated SheetView data. The similarity
    index may be useful for quantifying the stability of some cyclic
    quantity over time by comparing each sample in a SheetStack to the
    final SheetView element.
    """

    unit_range = param.Boolean(default=True, doc="""
        Whether to scale the similarity values linearly so that
        uncorrelated values have a value of zero and exactly matching
        elements are indicated with a value of 1.0. Negative values
        are then used to indicate anticorrelation.""")

    def _process(self, overlay):

        if len(overlay) != 2:
             raise Exception("The similarity index may only be computed using overlays of SheetViews.")

        if any(el.cyclic_range is None for el in overlay):
             raise Exception("The SheetViews in each  overlay must have a defined cyclic range.")

        prefA_data = overlay[0].N.data
        prefB_data = overlay[1].N.data
        # Ensure difference is symmetric distance.
        difference = abs(prefA_data - prefB_data)
        greaterHalf = (difference >= 0.5)
        difference[greaterHalf] = 1.0 - difference[greaterHalf]
        # Difference [0,0.5] so 2x normalizes...
        similarity = 1 - difference * 2.0
        # Subtracted from 1.0 as low difference => high stability
        # As this is made into a unit metric, uncorrelated has value zero.
        similarity = (2 * (similarity - 0.5)) if self.p.unit_range else similarity
        return [SheetView(similarity, bounds=overlay.bounds,
                          label=overlay[0].label+' Cyclic Similarity')]


Styles.Cyclic_Similarity    = Style(cmap='gray')
Styles.AutoCorrelation      = Style(cmap='gray')
Styles.Gradient             = Style(cmap='gray')
Styles.FFT_Power_Spectrum   = Style(cmap='gray')
Styles.Contours             = Style(color=Cycle(['b', 'g', 'r']))
